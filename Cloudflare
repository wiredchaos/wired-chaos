Perfect âœ…
Hereâ€™s a single copy-paste export you can drop into a fresh GitHub repo.
This contains everything Cloudflare needs for your wc-bus Worker, including package.json, tsconfig.json, wrangler.toml, the Worker code, and a signer script.


---

ðŸ“¦ wc-bus GitHub Export (Cloudflare Worker)

wired-chaos/
â”œâ”€ workers/
â”‚  â””â”€ wc-bus/
â”‚     â”œâ”€ package.json
â”‚     â”œâ”€ tsconfig.json
â”‚     â”œâ”€ wrangler.toml
â”‚     â”œâ”€ README.md
â”‚     â””â”€ src/
â”‚        â””â”€ index.ts
â”œâ”€ scripts/
â”‚  â””â”€ sign-hmac.mjs
â””â”€ .gitignore


---

.gitignore

node_modules
dist
.env
.DS_Store


---

workers/wc-bus/package.json

{
  "name": "wc-bus",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "src/index.ts",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "build": "tsc --noEmit",
    "check": "tsc --noEmit --strict"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20240925.0",
    "typescript": "^5.5.4",
    "wrangler": "^3.78.12"
  }
}


---

workers/wc-bus/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "WebWorker"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "types": ["@cloudflare/workers-types"]
  },
  "include": ["src"]
}


---

workers/wc-bus/wrangler.toml

name = "wc-bus"
main = "src/index.ts"
compatibility_date = "2024-11-20"

[[kv_namespaces]]
binding = "SWARM_KV"
id = ""          # fill with ID after `wrangler kv:namespace create SWARM_KV`
preview_id = ""

[vars]
CORS_ORIGIN = "https://wiredchaos.xyz"
RETENTION_DAYS = "14"
POLL_MAX_EVENTS = "100"

# Add after you attach custom domain:
# routes = [ "https://wc-bus.wiredchaos.xyz/*" ]

[dev]
port = 8787
local_protocol = "http"


---

workers/wc-bus/src/index.ts

export interface Env {
  SWARM_KV: KVNamespace;
  BUS_SECRET: string;
  CORS_ORIGIN: string;
  RETENTION_DAYS: string;
  POLL_MAX_EVENTS: string;
}

type WCEvent = {
  type: string; actor: string; payload?: unknown;
  ts?: number; traceId?: string; pii?: boolean; keys?: string[];
};

export default {
  async fetch(req: Request, env: Env): Promise<Response> {
    const url = new URL(req.url);
    if (req.method === "OPTIONS") return cors(new Response(null, { status: 204 }), env);

    if (url.pathname === "/status") {
      return cors(json({ ok: true, kv: !!env.SWARM_KV, now: Date.now() }), env);
    }

    if (url.pathname === "/bus/publish" && req.method === "POST") {
      const body = await req.text();
      const signed = await verify(body, req.headers.get("x-bus-sign") || "", env.BUS_SECRET);
      if (!signed) return cors(json({ ok:false, error:"bad-sign" }, 401), env);

      const raw = JSON.parse(body);
      const events: WCEvent[] = Array.isArray(raw) ? raw : [raw];
      const accepted: string[] = [];

      for (const e of events) {
        e.ts ??= Date.now();
        e.traceId ??= crypto.randomUUID();
        const day = new Date(e.ts).toISOString().slice(0,10);
        const key = `swarm:events:${day}:${e.traceId}`;
        await env.SWARM_KV.put(key, JSON.stringify(e));
        await env.SWARM_KV.put(`swarm:index:global:${e.ts}:${e.traceId}`, key);
        await env.SWARM_KV.put(`swarm:index:type:${e.type}:${e.ts}:${e.traceId}`, key);
        accepted.push(e.traceId);
      }
      return cors(json({ ok:true, accepted, traceIds:accepted }), env);
    }

    if (url.pathname === "/bus/poll" && req.method === "GET") {
      const type = url.searchParams.get("type");
      const since = Number(url.searchParams.get("since") || 0);
      const limit = Math.min(Number(url.searchParams.get("limit") || env.POLL_MAX_EVENTS || 100), 500);

      const prefix = type ? `swarm:index:type:${type}:` : `swarm:index:global:`;
      const list = await env.SWARM_KV.list({ prefix });

      const items = list.keys
        .map(k => ({ name: k.name, ts: Number(k.name.split(":")[3]) }))
        .filter(x => x.ts > since)
        .sort((a,b)=>a.ts-b.ts)
        .slice(0, limit);

      const events: WCEvent[] = [];
      for (const it of items) {
        const ptr = await env.SWARM_KV.get(it.name);
        if (!ptr) continue;
        const ev = await env.SWARM_KV.get(ptr);
        if (ev) events.push(JSON.parse(ev));
      }
      return cors(json({ events }), env);
    }

    return cors(json({ ok:false, error:"not-found" }, 404), env);
  }
} satisfies ExportedHandler<Env>;

function json(data: unknown, status = 200) {
  return new Response(JSON.stringify(data), { status, headers: { "content-type": "application/json" }});
}

async function verify(payload: string, sigHex: string, secret: string) {
  const key = await crypto.subtle.importKey("raw", enc(secret), { name:"HMAC", hash:"SHA-256" }, false, ["sign"]);
  const sig = await crypto.subtle.sign("HMAC", key, enc(payload));
  const hex = [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,"0")).join("");
  return hex === sigHex;
}

const enc = (s:string)=>new TextEncoder().encode(s);

function cors(res: Response, env: Env){
  const h = new Headers(res.headers);
  h.set("access-control-allow-origin", env.CORS_ORIGIN || "*");
  h.set("access-control-allow-headers", "content-type,x-bus-sign");
  h.set("access-control-allow-methods", "GET,POST,OPTIONS");
  return new Response(res.body, { status: res.status, headers: h });
}


---

workers/wc-bus/README.md

# WC-BUS (Cloudflare Worker)

Event bus for WIRED CHAOS.

### Endpoints
- `GET /status` â€” health JSON
- `POST /bus/publish` â€” HMAC signed publish (header `x-bus-sign`)
- `GET /bus/poll?type=...&since=...&limit=...` â€” read events

### Setup
```bash
wrangler login
cd workers/wc-bus
npm install
npx wrangler kv:namespace create SWARM_KV   # paste id into wrangler.toml
npx wrangler secret put BUS_SECRET          # paste random hex string
npx wrangler deploy

Attach a custom domain in Cloudflare: wc-bus.wiredchaos.xyz â†’ then add to wrangler.toml:

routes = [ "https://wc-bus.wiredchaos.xyz/*" ]

â€¦and redeploy.

---

## scripts/sign-hmac.mjs
```js
// Usage: node scripts/sign-hmac.mjs "<secret>" "<payload>"
import { createHmac } from "node:crypto";
const [,, secret, payload] = process.argv;
if (!secret || !payload) {
  console.error('Usage: node scripts/sign-hmac.mjs "<secret>" "<payload>"');
  process.exit(1);
}
const sig = createHmac("sha256", secret).update(payload).digest("hex");
console.log(sig);


---

âœ… Next Steps

1. Copy all of the above into a fresh folder wired-chaos/.


2. Push to GitHub:

git init
git add .
git commit -m "Add wc-bus Worker"
git branch -M main
git remote add origin https://github.com/<your-user>/wired-chaos.git
git push -u origin main


3. In Cloudflare dashboard:

Create KV namespace â†’ paste ID into wrangler.toml.

Add secret: wrangler secret put BUS_SECRET.

Deploy: npm run deploy.

Attach custom domain: wc-bus.wiredchaos.xyz.