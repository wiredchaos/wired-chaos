ðŸ“¦ wc-bus GitHub Export (Cloudflare Worker)

wired-chaos/
â”œâ”€ workers/
â”‚  â””â”€ wc-bus/
â”‚     â”œâ”€ package.json
â”‚     â”œâ”€ tsconfig.json
â”‚     â”œâ”€ wrangler.toml
â”‚     â”œâ”€ README.md
â”‚     â””â”€ src/
â”‚        â””â”€ index.ts
â”œâ”€ scripts/
â”‚  â””â”€ sign-hmac.mjs
â””â”€ .gitignore


---

.gitignore

node_modules
dist
.env
.DS_Store


---

workers/wc-bus/package.json

{
  "name": "wc-bus",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "main": "src/index.ts",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy",
    "build": "tsc --noEmit",
    "check": "tsc --noEmit --strict"
  },
  "devDependencies": {
    "@cloudflare/workers-types": "^4.20240925.0",
    "typescript": "^5.5.4",
    "wrangler": "^3.78.12"
  }
}


---

workers/wc-bus/tsconfig.json

{
  "compilerOptions": {
    "target": "ES2022",
    "lib": ["ES2022", "WebWorker"],
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "types": ["@cloudflare/workers-types"]
  },
  "include": ["src"]
}


---

workers/wc-bus/wrangler.toml

name = "wc-bus"
main = "src/index.ts"
compatibility_date = "2024-11-20"

[[kv_namespaces]]
binding = "SWARM_KV"
id = ""          # fill with ID after `wrangler kv:namespace create SWARM_KV`
preview_id = ""

[vars]
CORS_ORIGIN = "https://wiredchaos.xyz"
RETENTION_DAYS = "14"
POLL_MAX_EVENTS = "100"

# Add after you attach custom domain:
# routes = [ "https://wc-bus.wiredchaos.xyz/*" ]

[dev]
port = 8787
local_protocol = "http"


---

workers/wc-bus/src/index.ts

export interface Env {
  SWARM_KV: KVNamespace;
  BUS_SECRET: string;
  CORS_ORIGIN: string;
  RETENTION_DAYS: string;
  POLL_MAX_EVENTS: string;
}

type WCEvent = {
  type: string; actor: string; payload?: unknown;
  ts?: number; traceId?: string; pii?: boolean; keys?: string[];
};

export default {
  async fetch(req: Request, env: Env): Promise<Response> {
    const url = new URL(req.url);
    if (req.method === "OPTIONS") return cors(new Response(null, { status: 204 }), env);

    if (url.pathname === "/status") {
      return cors(json({ ok: true, kv: !!env.SWARM_KV, now: Date.now() }), env);
    }

    if (url.pathname === "/bus/publish" && req.method === "POST") {
      const body = await req.text();
      const signed = await verify(body, req.headers.get("x-bus-sign") || "", env.BUS_SECRET);
      if (!signed) return cors(json({ ok:false, error:"bad-sign" }, 401), env);

      const raw = JSON.parse(body);
      const events: WCEvent[] = Array.isArray(raw) ? raw : [raw];
      const accepted: string[] = [];

      for (const e of events) {
        e.ts ??= Date.now();
        e.traceId ??= crypto.randomUUID();
        const day = new Date(e.ts).toISOString().slice(0,10);
        const key = `swarm:events:${day}:${e.traceId}`;
        await env.SWARM_KV.put(key, JSON.stringify(e));
        await env.SWARM_KV.put(`swarm:index:global:${e.ts}:${e.traceId}`, key);
        await env.SWARM_KV.put(`swarm:index:type:${e.type}:${e.ts}:${e.traceId}`, key);
        accepted.push(e.traceId);
      }
      return cors(json({ ok:true, accepted, traceIds:accepted }), env);
    }

    if (url.pathname === "/bus/poll" && req.method === "GET") {
      const type = url.searchParams.get("type");
      const since = Number(url.searchParams.get("since") || 0);
      const limit = Math.min(Number(url.searchParams.get("limit") || env.POLL_MAX_EVENTS || 100), 500);

      const prefix = type ? `swarm:index:type:${type}:` : `swarm:index:global:`;
      const list = await env.SWARM_KV.list({ prefix });

      const items = list.keys
        .map(k => ({ name: k.name, ts: Number(k.name.split(":")[3]) }))
        .filter(x => x.ts > since)
        .sort((a,b)=>a.ts-b.ts)
        .slice(0, limit);

      const events: WCEvent[] = [];
      for (const it of items) {
        const ptr = await env.SWARM_KV.get(it.name);
        if (!ptr) continue;
        const ev = await env.SWARM_KV.get(ptr);
        if (ev) events.push(JSON.parse(ev));
      }
      return cors(json({ events }), env);
    }

    return cors(json({ ok:false, error:"not-found" }, 404), env);
  }
} satisfies ExportedHandler<Env>;

function json(data: unknown, status = 200) {
  return new Response(JSON.stringify(data), { status, headers: { "content-type": "application/json" }});
}

async function verify(payload: string, sigHex: string, secret: string) {
  const key = await crypto.subtle.importKey("raw", enc(secret), { name:"HMAC", hash:"SHA-256" }, false, ["sign"]);
  const sig = await crypto.subtle.sign("HMAC", key, enc(payload));
  const hex = [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,"0")).join("");
  return hex === sigHex;
}

const enc = (s:string)=>new TextEncoder().encode(s);

function cors(res: Response, env: Env){
  const h = new Headers(res.headers);
  h.set("access-control-allow-origin", env.CORS_ORIGIN || "*");
  h.set("access-control-allow-headers", "content-type,x-bus-sign");
  h.set("access-control-allow-methods", "GET,POST,OPTIONS");
  return new Response(res.body, { status: res.status, headers: h });
}


---

workers/wc-bus/README.md

# WC-BUS (Cloudflare Worker)

Event bus for WIRED CHAOS.

### Endpoints
- `GET /status` â€” health JSON
- `POST /bus/publish` â€” HMAC signed publish (header `x-bus-sign`)
- `GET /bus/poll?type=...&since=...&limit=...` â€” read events

### Setup
```bash
wrangler login
cd workers/wc-bus
npm install
npx wrangler kv:namespace create SWARM_KV   # paste id into wrangler.toml
npx wrangler secret put BUS_SECRET          # paste random hex string
npx wrangler deploy

Attach a custom domain in Cloudflare: wc-bus.wiredchaos.xyz â†’ then add to wrangler.toml:

routes = [ "https://wc-bus.wiredchaos.xyz/*" ]

â€¦and redeploy.

---

## scripts/sign-hmac.mjs
```js
// Usage: node scripts/sign-hmac.mjs "<secret>" "<payload>"
import { createHmac } from "node:crypto";
const [,, secret, payload] = process.argv;
if (!secret || !payload) {
  console.error('Usage: node scripts/sign-hmac.mjs "<secret>" "<payload>"');
  process.exit(1);
}
const sig = createHmac("sha256", secret).update(payload).digest("hex");
console.log(sig);


---

âœ… Next Steps

1. Copy all of the above into a fresh folder wired-chaos/.


2. Push to GitHub:

git init
git add .
git commit -m "Add wc-bus Worker"
git branch -M main
git remote add origin https://github.com/<your-user>/wired-chaos.git
git push -u origin main


3. In Cloudflare dashboard:

Create KV namespace â†’ paste ID into wrangler.toml.

Add secret: wrangler secret put BUS_SECRET.

Deploy: npm run deploy.

Attach custom domain: wc-bus.wiredchaos.xyz.

// Minimal WIRED CHAOS agent (runs in GitHub Actions on a schedule)
import crypto from "node:crypto";

const BUS_BASE = process.env.BUS_BASE;       // e.g. https://wc-bus.wiredchaos.xyz
const BUS_SECRET = process.env.BUS_SECRET;   // same secret you set in Cloudflare
const AGENT_ID = process.env.AGENT_ID || "wlxp-agent";

if (!BUS_BASE || !BUS_SECRET) {
  console.error("Missing BUS_BASE or BUS_SECRET env.");
  process.exit(1);
}

async function hmac(payload) {
  return crypto.createHmac("sha256", BUS_SECRET).update(payload).digest("hex");
}

async function publish(event) {
  const body = JSON.stringify(event);
  const sign = await hmac(body);
  const res = await fetch(`${BUS_BASE}/bus/publish`, {
    method: "POST",
    headers: { "content-type": "application/json", "x-bus-sign": sign },
    body
  });
  if (!res.ok) throw new Error(`publish failed: ${res.status} ${await res.text()}`);
  return res.json();
}

async function poll({ type, sinceMs, limit = 50 }) {
  const u = new URL(`${BUS_BASE}/bus/poll`);
  if (type) u.searchParams.set("type", type);
  if (sinceMs) u.searchParams.set("since", String(sinceMs));
  u.searchParams.set("limit", String(limit));
  const res = await fetch(u);
  if (!res.ok) throw new Error(`poll failed: ${res.status} ${await res.text()}`);
  return res.json();
}

(async () => {
  const now = Date.now();

  // 1) Heartbeat
  await publish({
    type: "agent.status",
    actor: AGENT_ID,
    payload: { ok: true, ts: now },
    ts: now
  });

  // 2) Look for pings in the last 5 minutes
  const fiveMinAgo = now - 5 * 60 * 1000;
  const { events = [] } = await poll({ type: "agent.ping", sinceMs: fiveMinAgo });

  for (const e of events) {
    // Basic guard to avoid loops: only respond once per traceId
    if (!e?.traceId || e?.actor === AGENT_ID) continue;

    // 3) Reward the actor who pinged with +5 XP
    const targetActor = e.actor || "unknown";
    await publish({
      type: "wl.xp_gain",
      actor: targetActor,
      payload: { delta: 5, reason: "auto-reward:ping" },
      ts: Date.now()
    });
  }

  console.log(`OK heartbeat + processed ${events.length} ping(s)`);
})().catch(err => {
  console.error(err);
  process.exit(1);
});

name: WIRED CHAOS Bot (wlxp-agent)

on:
  schedule:
    - cron: "*/5 * * * *"   # every 5 minutes
  workflow_dispatch:        # allow manual run

jobs:
  run-bot:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Run agent
        run: node bots/wlxp-agent.mjs
        env:
          BUS_BASE: ${{ secrets.BUS_BASE }}     # e.g. https://wc-bus.wiredchaos.xyz
          BUS_SECRET: ${{ secrets.BUS_SECRET }} # same as Cloudflare Worker
          AGENT_ID: "wlxp-agent"